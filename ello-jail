#!/bin/sh

# This script uses two global variables
# 1) ello_jail_dir points to the installation of ello-jail.
#       It is this directory that contains the base components
#       and jail templates
# 2) jail_path is the directory in which the script will create
#       jails


readonly CONFIG_LOCATION=/usr/local/etc/ello-jail


ELLO_JAIL_USER_CHANGED_JAIL_PATH=""

readonly ELLO_JAIL_ELLO_JAIL_DIR_OPT='b:'
readonly ELLO_JAIL_JAIL_PATH_OPT='d:'
readonly ELLO_JAIL_MIRROR_OPT='m:'
readonly ELLO_JAIL_RELEASE_OPT='r:'

readonly ELLO_JAIL_GLOBAL_OPTS="${ELLO_JAIL_ELLO_JAIL_DIR_OPT}\
${ELLO_JAIL_JAIL_PATH_OPT}${ELLO_JAIL_MIRROR_OPT}${ELLO_JAIL_RELEASE_OPT}"


# Changes the ello_jail_dir variable to its first argument
set_ello_jail_dir() {
    ello_jail_dir=$1
    set_jail_path "$ello_jail_dir/jails"
}

# echoes the ello_jail_dir to stdout
get_ello_jail_dir() {
    echo $ello_jail_dir
}

# Changes the jail_path variable to its first argument
set_jail_path() {
    [ -z "$ELLO_JAIL_USER_CHANGED_JAIL_PATH" ] && \
        jail_path=$1
}

set_jail_path_to_user_value() {
    ELLO_JAIL_USER_CHANGED_JAIL_PATH=''
    set_jail_path $1
    ELLO_JAIL_USER_CHANGED_JAIL_PATH="true"
}

get_jail_path() {
    echo $jail_path
}


# echoes the directory in which to store the base filesystems to
# stdout
get_base_dir() {
    echo "$(get_ello_jail_dir)/base"
}

# echoes the directory in which to look for and store templates
# to stdout
get_templates_dir() {
    echo "$(get_ello_jail_dir)/templates"
}


# Sets the global mirror option to the first argument
set_mirror() {
    ello_jail_mirror=$1
}

# echoes the chosen mirror to stdout
get_mirror() {
    echo $ello_jail_mirror
}

# Set the FreeBSD release version which to fetch
set_release() {
    ello_jail_freebsd_release=$1
}

# echoes the jails' freebsd release version to stdout
get_release() {
    echo $ello_jail_freebsd_release
}

# Load configuration
[ -r $CONFIG_LOCATION ] && . $CONFIG_LOCATION


[ -n "$(get_ello_jail_dir)" ] ||  set_ello_jail_dir '/usr/local/ello-jail'
[ -n "$(get_jail_path)" ] || set_jail_path "$ello_jail_dir/jails"
[ -n "$(get_mirror)" ] || set_mirror 'ftp.nl.freebsd.org'
[ -n "$(get_release)" ] || set_release `uname -r`


err() {
    echo "Error:" $@ 1>&2
    exit 1
}

warn() {
    echo "Warning: " $@ 1>&2
}

# empty_dir returns successfully if its first argument
# is an empty directory
empty_dir() {
    [ "$#" = 1 ] || err "empty_dir expects one argument"
    [ -z "$(ls -A $1)" ]
}

dir_for_jail() {
    [ $# = 1 ] || err "dir_for_jail expects one argument"
    local jail_name=$1

    # awk outputs only the block belonging to the jail
    # grep filters out the path parameter
    # sed outputs the value between quotes to stdout
    local dir_to_jail=$(awk '/'$jail_name'[ ]*\{/, /.*\}.*/' /etc/jail.conf | \
                        grep path | \
                        sed -E 's/.*"(.*)".*;.*/\1/g')

    # if no match is found, the jail might not have been created
    # in which case we default to a subdirectory with the jail's name
    # inside $jail_path
    if [ $? -gt 0 ] || [ -z "$dir_to_jail" ]; then 
        dir_to_jail=$(get_jail_path)/$jail_name;
    fi

    echo $dir_to_jail
}

dir_for_template() {
    [ $# = 1 ] || err "dir_for_template expects one argument"
    echo $(get_templates_dir)/$1
}

dir_for_base_part() {
    [ $# = 1 ] || err "dir_for_base_part expects one argument"
    echo $(get_base_dir)/$1
}

# echoes the jails' base release number to stdout
get_jail_base_release() {
    local fv="$(dir_for_base_part ro)/bin/freebsd-version"
    [ -x "$fv" ] && $fv || err "Could not determine the base jail's release information"
}


# is_valid_label returns successfully if its first argument contains
# only English letters, hyphens and decimal digits.
is_valid_label() {
    local label=$1
    [ ${#label} -gt 0 ] && [ ${#label} -lt 64 ] && \
        echo $label | grep -qE '^[a-zA-Z0-9\-]+$'
}

# is_valid_hostname returns successfully if it is given a number (minimum 1) of
# hostnames that are valid FQDN's. The function will return unsuccessfully if it
# encounters an invalid FQDN, in which case its exit code equals the index of
# the first invalid hostname
is_valid_hostname() {
    [ $# -lt 1 ] && err "is_valid_hostname ($LINENO) expects at least \
        one argument"
    local hname=""
    local n=1
    for hname; do
        # Hostnames may not contain double dots
        case "$hname" in *..*) return $n;; esac
        [ ${#hname} -lt 256 ] || return $n
        for label in $(echo $hname | sed -E 's/\./ /g'); do
            is_valid_label $label || return $n
        done
        n=$(($n+1))
    done
    return 0
}

# is_valid_jailname returns successfully if its first argument does not contain
# dots, spaces and forward slashes
is_valid_jailname() {
    echo $1 | grep -qv '[\. /]'
}

# hostname_to_jailname translates a hostname into a jailname by replacing any
# dots by underscores.
hostname_to_jailname() {
    echo $1 | sed -E 's/\.+/_/g'
}

# is_template returns successfully if its first argument is a directory inside
# the templates directory
is_template() {
    [ -d "$templates_dir/$1" ]
}

# is_valid_ipv4_address_list returns successfully if its first argument can
# be used to set the jail's ipv4.addr parameter
is_valid_ipv4_address_list() {
    # TODO: Implement
    true
}

# is_valid_ipv6_address_list returns successfully if its first argument can
# be used to set the jail's ipv6.addr parameter
is_valid_ipv6_address_list() {
    # TODO: Implement
    true
}

# A space-separated list of directories that belong to the read only part of the
# base jail
readonly READ_ONLY_DIRS="./COPYRIGHT \
                         ./bin/* \
                         ./boot/* \
                         ./lib/* \
                         ./libexec/* \
                         ./rescue/* \
                         ./sbin/* \
                         ./sys/* \
                         ./usr/bin/* \
                         ./usr/games/* \
                         ./usr/include/* \
                         ./usr/lib/* \
                         ./usr/lib32/* \
                         ./usr/libdata/* \
                         ./usr/libexec/* \
                         ./usr/sbin/* \
                         ./usr/share/* \
                         ./usr/src/*"

# has_base_part returns successfully if its first argument is a non-empty directory
# in the base directory
has_base_part() {
    [ "$#" = 1 ] || err "has_base_part expects one argument"
    local target=$(dir_for_base_part $1)
    [ -d "$target" ] && ! empty_dir $target
}

# Checks if ello_jail_dir contains at least a ro and rw
# base part
is_not_prepared() {
    ! has_base_part ro || ! has_base_part rw
}


extract_base() {
    [ "$#" -lt 2 ] && err "extract (${LINENO}): expecting 2 arguments"
    local archive=$1
    local part=$2
    local option=""
    
    case $part in 
        rw)
            option=exclude;;
        ro)
            option=include;;
        *)
            err "extract (${LINENO}): third argument must be 'ro' or 'rw'";;
    esac

    inclusion_pattern=`echo $READ_ONLY_DIRS | awk '{
        for (i = 1; i <= NF; i++)
            printf "--'$option'=%s ", $i }'`

    tar -xpf $archive $inclusion_pattern -C $(dir_for_base_part $part)
}



chflag_and_rm() {
    [ -d $1 ] || return 0 
    chflags -R noschg $1 &&
        rm -rf $1 > /dev/null 2>&1
}

clone() {
    local from=$1
    local what=$2
    local to=$3
    shift 3
    tar $@ -f - -C $from -c $what | tar -xf - -p -C $to
}

clone_from_base() {
    [ $# -lt 3 ] && err "clone_from_base requires at least 3 arguments"
    local part=$1
    has_base_part $part || err "clone_from_base ($LINENO): base part '$part' not installed"

    local from_dir=$(dir_for_base_part $part)
    local what=$2
    local to_dir=$3

    shift 3

    clone $from_dir $what $to_dir $@
}

clone_from_base_rw() {
    clone_from_base rw $@
}

clone_from_base_ro() {
    clone_from_base ro $@
}


# Merges the contents of a template into a jail
# $1 should contain the jail name
# $2 is an optional template name, if omitted 'default' is used
merge_template() {
    [ $# -lt 1 ] && err "merge_template requires at least one argument"

    local jail_name=$1
    local template_name=${2:-default}

    clone $(dir_for_template $template_name) . $(dir_for_jail $jail_name)
}

create_template() {
    local template_name=$1
    local t_root=$(dir_for_template $template_name)

    cleanup_and_err() {
        rm -rf $t_root > /dev/null 2>&1
        err $@
    }

    [ -d "$t_root" ] && \
        cleanup_and_err "create_template ($LINENO): Cannot create template \"${template_name}\", $t_root exists"

    mkdir -p $t_root || \
        cleanup_and_err "create_template ($LINENO): Could not create template directory $t_root"

    clone_from_base_rw "etc" $t_root -n || \
        cleanup_and_err "create_template ($LINENO): Could not create etc directory"
    clone "/" "etc/localtime" "$t_root" || \
        warn "create_template ($LINENO): Could not copy /etc/localtime to template. \
            Remember to set the correct timezone manually."
    clone_from_base_rw "etc/master.passwd" $t_root && \
        sed -E 's/^(root|toor):[^:]*:/\1:*:/g' $t_root/etc/master.passwd > $t_root/etc/master.passwd || \
        warn "create_template ($LINENO): Could not disable root password based logins."
}


create_jail() {

    local jail_name=''
    local jail_template='default'
    local jail_hostname=''
    local jail_ipv4_addr=''
    local jail_ipv6_addr=''
    local jail_components=''
    local quiet="false"


    OPTIND=1
    while getopts $ELLO_JAIL_GLOBAL_OPTS'n:h:t:4:6:q' arg; do
        case $arg in
            n)
                jail_name=$OPTARG
                ;;
            t)
                jail_template=$OPTARG
                ;;
            h)
                jail_hostname=$OPTARG
                ;;
            4)
                jail_ipv4_addr=$OPTARG
                ;;
            6)
                jail_ipv6_addr=$OPTARG
                ;;
            q)
                quiet="true"
                ;;
        esac
    done

    # Validate jail name
    [ -z "$jail_name" ] && usage
    is_valid_jailname $jailname || \
        err "$jail_name is not a valid jailname"

    # Validate hostname
    [ -z "$jail_hostname" ] && warn 'No hostname given, using jailname' && \
        : ${jail_hostname:=$jail_name}
    is_valid_hostname $jail_hostname || \
        err "$jail_hostname is not a valid hostname"

    # Validate template
    : ${jail_template:='default'}
    is_template $jail_template || \
        err "Could not find a template named '$jail_template'"

    # Validate IP addresses
    is_valid_ipv4_address_list $jail_ipv4_addr || \
        err "'$jail_ipv4_addr' is not a valid address list"
    is_valid_ipv6_address_list $jail_ipv6_addr || \
        err "'$jail_ipv6_addr' is not a valid address list"


    cat <<EOF
About to create a jail:
    name:           $jail_name
    hostname:       $jail_hostname
    template:       $jail_template
    jail_ipv4_addr: $jail_ipv4_addr
    jail_ipv6_addr: $jail_ipv6_addr
EOF

    local dest_dir=$(dir_for_jail $jail_name)
    local target=""
    local ro_dir=""
    
    cleanup_and_err() {
        rm -rf $dest_dir > /dev/null 2>&1
        err $@
    }

    say() {
        $quiet || echo $@
    }

    [ -d "$dest_dir" ] && \
        err "create_jail ($LINENO): Cannot create a jail named \"${jail_name}\", $dest_dir exists"


    say "Initializing read only filesystem..."
    mkdir -p $dest_dir/ro
    # Ensure that usr in our new jail has the same permissions as usr in base-ro
    # The -n option forces tar to operate non-recursively, i.e. to only copy the
    # usr directory, not its contents
    clone_from_base_ro usr $dest_dir -n || \
        err "create_jail ($LINENO): Error while cloning the usr \
            directory."
    
    for ro_dir in $READ_ONLY_DIRS; do
        target=${ro_dir#./}
        target=${target%'/*'}
        ln -s /ro/$target $dest_dir/$target
    done

    say "Initializing writable filesystem..."
    clone_from_base_rw . $dest_dir || \
        cleanup_and_err "create_jail ($LINENO): Error while cloning \
            writable filesystem."

    # Finally merge template
    say "Merging template '$jail_template' with writable filesystem..."
    merge_template $jail_name $jail_template

    # write config
    say "Writing configuration to /etc/jail.conf..."
    cat >> /etc/jail.conf <<EOF
$jail_name {
    host.hostname="$jail_hostname";
    mount="$(dir_for_base_part ro) $dest_dir/ro nullfs ro 0 0";
    ip4.addr="$jail_ipv4_addr";
    ip6.addr="$jail_ipv6_addr";
    exec.start="/bin/sh /etc/rc";
    exec.stop="/bin/sh /etc/rc.shutdown";
    mount.devfs;
    exec.clean;
    path="$dest_dir";
}
EOF
    say "Jail '$jail_name' succcessfully created."
}

fetch_component() {
    local mirror="http://$(get_mirror)/os/FreeBSD/releases/$(uname -m)/$(get_release)"
    fetch "$mirror/${1}.txz" -o "$2/${1}.txz"
}

# add_component installs one component provided by its first argument into the base
# read-only system. 
add_component() {
    local component=$1
    local tmp_dir=""

    cleanup() {
        [ -n "$tmp_dir" ] && [ -d "$tmp_dir" ] && rm -rf $tmp_dir > /dev/null 2>&1
    }

    cleanup_and_err() {
        cleanup
        err $@
    }

    case "$component" in
        doc|games|ports|src) 
            ;;
        lib32)
            [ `uname -m` = 'amd64' ] || err "lib32 is only available on amd64"
            ;;
        base) 
            add_base_component 
            return $?
            ;;
        *)
            err "unknown component: '$component'"
            ;;
    esac

    tmp_dir=$(mktemp -d)
    [ $? -gt 0 ] && err "add_component ($LINENO): could not create temporary directory"
    
    fetch_component $component $tmp_dir || \
        cleanup_and_err "add_component ($LINENO): could not download component '$component'"

    echo "Extracting $component"
    tar -xf "${tmp_dir}/${component}.txz" -C $(dir_for_base_part ro) || \
        cleanup_and_err "add_component ($LINENO): error while extracting ${component}"

    cleanup
    echo "Finished adding component '$component'"
}

# Takes any number of components as its arguments and installs them into the
# read only base filesystem
add_components() {
    for component; do
        add_component $component
    done
}



# Prepares the system for running jails,
# $1: directory to which the jail skeleton is installed
# $2: release of the jail
# $3: mirror
prepare() {
    local tmp_dir=""
    local local_dir=''
    local files='base'
    
    cleanup() {
        [ -d "$tmp_dir" ] && rm -rf $tmp_dir > /dev/null 2>&1
    }

    cleanup_and_err() {
        cleanup
        for i in rw ro; do
            j=$(dir_for_base_part $i)
            [ -d "$j" ] && chflag_and_rm $j
        done
        err $@
    }
cat <<-EOF
About to install a base filesystem for ello-jail
    base directory:         $(get_base_dir)
    templates directory:    $(get_templates_dir)
    release:                $(get_release)
    mirror:                 $(get_mirror)
EOF

    for p in ro rw; do
        has_base_part $p && \
            err "Read only base filesystem already exists at $(dir_for_base_part $p)"
    done

    for p in ro rw; do
        mkdir -p $(dir_for_base_part $p) || \
            cleanup_and_err "Error while creating $checkdir"
    done

    echo "Downloading distribution archives... "
    tmp_dir=$(mktemp -d)
    for file in $files; do
        fetch_component 'base' $tmp_dir || \
            cleanup_and_err "Error while fetching ${file}.txz"
    done

    echo "Extracting base jail... " 
    for file in $files; do
        for p in ro rw; do
            extract_base ${tmp_dir}/${file}.txz $p || \
                cleanup_and_err "Error while extracting ${tmp_dir}/${file}"
        done
    done

    echo "Creating default template... "
    create_template default

    echo "Cleaning up... "
    cleanup
    echo "Successfully prepared ello-jail for use"
}


upgrade() {
    local log_file=/var/log/ello-jail-upgrade
    local target=""
    local cycles=0

    cleanup() {
    }

    cleanup_and_err() {
        err $@
    }

    : > $log_file
    echo -n 'Updating base'
    for i in ro rw; do
        target=$(dir_for_base_part $i)
        echo $target
        echo -n '.'
        echo 'y' | UNAME_r=$(get_jail_base_release) get_base_PAGER=cat freebsd-update upgrade -b $target -r $(get_release) > $log_file 2>&1 || \
            cleanup_and_err "upgrade ($LINENO): Error while fetching upgrade"

        cycles=0
        while [ $? -eq 0 ]; do
            cycles=$(($cycles+1))
            echo -n '.'
            PAGER=cat freebsd-update install -b $target > $log_file 2>&1
        done
    done
    echo ' done'

    if [ $cycles -gt 1 ]; then # We need to update the individual jails as well for changes in configuration files
        # TODO: Update individual jails
    fi

    cleanup
}

usage() {
    cat <<EOF
Usage: `basename $0` [options] command

Global options:
    -${ELLO_JAIL_ELLO_JAIL_DIR_OPT%:} ello-jail-dir    -- Directory where to put and look for the jail base filesystem 
                           and templates (default: /usr/local/ello-jail)
    -${ELLO_JAIL_JAIL_PATH_OPT%:} jails-dir        -- Directory where to put and look for jails
                           (default: /usr/local/ello-jail/jails)
    -${ELLO_JAIL_RELEASE_OPT%:} release          -- Release level of which to download the system components (when 
                           used with prepare) or to which to upgrade the jail base filesystem 
                           (when used with upgrade). Defaults to the release level of the host 
                           system
    -${ELLO_JAIL_MIRROR_OPT%:} mirror           -- Mirror from which to download system components.
Commands:
    prepare             -- Install the base jail filesystem and templates to 
                           ello-jail-dir
    create-jail         -- Create a new jail
    create-template     -- Create a new template
    add-components      -- Install additional system components into the base
                           jail filesystem. 
    upgrade             -- Upgrade the base jail filesystem to a newer release,
                           using freebsd-update(8)
    usage               -- Display this message
EOF
    exit 0
}

if [ "$#" -lt 1 ]; then
    usage
fi

# The command should be the last argument given to this script
command=""
for command; do :; done

# Parse global options first
OPTIND=1
while getopts $ELLO_JAIL_GLOBAL_OPTS arg; do
    case $arg in
        $ELLO_JAIL_JAIL_PATH_OPT) set_jail_path_to_user_value $OPTARG;;
        $ELLO_JAIL_ELLO_JAIL_DIR_OPT) set_ello_jail_dir $OPTARG;;
        $ELLO_JAIL_RELEASE_OPT) set_release $OPTARG ;;
        $ELLO_JAIL_MIRROR_OPT) set_mirror $OPTARG;;
    esac
done



case "$command" in
    prepare|usage) ;;
    *)
        if is_not_prepared; then
            err "Could not find the base filesystem for jails. Did you run '`basename $0` prepare'?"
        fi
        ;;
esac

case $command in
    "prepare")
        prepare $@
        ;;
    "create-jail")
        create_jail $@
        ;;
    "create-template")
        create_template $@
        ;;
    "add-components")
        add_components $@
        ;;
    "upgrade")
        upgrade
        ;;
    "usage")
        usage
        ;;
    *)
        err "Unknown function \"${command}\""
        usage
        ;;
esac
